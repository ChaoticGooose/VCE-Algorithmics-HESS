<h1>VSV VCE Algorithmics SAT U3</h1>
<p>Task 1: <strong>Shortest Path</strong>
<sub>The response force needs to be deployed from Bendigo to reach the target site as quickly as possible.</sub></p>
<p>Task 2: <strong>Radius Vaccination</strong>
<sub>The medical team must visit every town within a given radius and vaccinate everybody in the shortest possible time.</sub></p>
<h3>Table of Contents</h3>
<ol>
<li><a href="#part-1-model-and-specification">Model and Specification</a></li>
<li><a href="#part-2-design-your-algorithm">Design your Algorithm</a></li>
<li><a href="#part-3-implementation">Implementation</a></li>
<li><a href="#part-4-evaluation">Evaluation</a></li>
</ol>
<h2>0. Aim and Introduction</h2>
<p>The following report outlines the design and implementation of two algorithms to address real-world problems faced by the Sanitation and Medical Teams in a fictional urban environment. The goal is to develop sutable algorithms to combat the spread of &quot;Pangobats&quot;, Making use of efficient algorithmic decsign to optimize the task.</p>
<h2>Part 1: <strong>Model and Specification</strong></h2>
<h3>1.1 Model</h3>
<p>The algorithmic problem at hand is to design an efficient system for managing the governmentâ€™s response to sightings of Flying Pangolins (Pangobats) in Victoria, which are carriers of Itchy Nose Syndrome (INS). This disease is highly contagious and detrimental, necessitating a swift and coordinated response. The government has established two teams to address this issue: a Response Team and a Medical Team. The Response Team is tasked with quickly reaching the target site, while the Medical Team must visit every town within a given radius and vaccinate all residents.</p>
<p>In the real world, the spread of infectious diseases carried by animals like Pangobats can have severe consequences for public health and the economy. Timely response, efficient resource allocation, and strategic planning are crucial to containing such outbreaks. The algorithmic solution needs to optimize the deployment of resources, minimize response time, prioritize vulnerable populations, and ensure thorough coverage of affected areas to mitigate the impact of INS outbreaks.</p>
<p>The teams are provided with a map of the relevent areas. The map is represented using a Graph ADT, with each town as a node and each road as an edge. This graph will be a weighted cyclic undirected graph, with each edge containing the length of the road as the weight and the time to travel the road as an additional attributes. Each node also contains attributes such as population, median household weekly income, average age, and 2D GPS coordinates. This infomation is vital to determining order of towns to visit and determining the quickest path to take. For simplicity, the third dimension of towns (altitude) is disregarded, thereby excluding altitude-based distance calculations. In the real world this would be relevent as the Pandobats would have to fly over mountains thereby increasing the time taken to reach the target site, this is not taken into account in this model.</p>
<p>The Medical team operates as a single unit with only one vehicle, It is assumed that the vehicle can carry an infinite amount of vaccines, has an infinite amount of fuel and can vaccinate any sized town instantaniously once reached. In addition to this, road traffic will not be taken into account in the model. For the purposes of this model thease assumptions are made, although further iterations of the algorithms would have to take into account refeuling and restocking for longer routes containing a greater number of towns and potential traffic. With thease assumptions in mind, the vehicle will travel at a constant speed and can visit all towns within the radius in a single trip.</p>
<p>The Algorithm that must be designed to generate a path for the medical team to travel is generically known as a Travelling Salesman Problem (TSP), where the goal is to visit every node in a graph once and return to the starting point in the shortest possible time. In this instance the algorithm will need to find all the relevent nodes inside of a given radius, then generate a path connecting all of the relevent nodes. As the generated series of nodes is not always Hamiltonian, the generated path may revisit nodes where reasnoble. This is a slight diffrence between a TSP, where a TSP would generate a Hamiltonian Circuit, This algotithm will create a more general circuit.</p>
<p>When calculating the relevent towns within the radius the distance between towns should be calculated using the Haversine formula, which takes into account the curvature of the Earth, providing a more accurate distance between two points on the Earth's surface. As the Pangobats can fly, they needn't follow the roads and can travel in a straight line between towns. This is important to note as the distance between towns is not the same as the distance between roads, this is taken into account when calculating the distance between towns within the radius. The Edge weights (Time taken to Travel) and Edge Length should be used when calculating the shortest path between two towns for the vehicle to travel.</p>
<p>In this task real world considerations must be taken into account to ensure the algorithm can prioritize higher risk towns. The algorithm must prioritize towns based on population density, income, and age. This is important as outbreaks are more common in towns with higher population density, lower income, and older populations. Addressing these towns first should lower the impact that an outbreak can have on the surrounding community and stop further spread, and therefor minimising the overall resources required to completely exterminate the population of Pandobats and Treat the overall community. This priotitization will be represented through the use of a priority queue, which will order the towns based on the given attributes. Towns with more dense population will be treated with the greatest priority, Then towns with a higher median age and then towns with a lower median income. This will ensure that the towns most at risk are visited first, then a shorter path can be calculated between these towns to minimize travel time.</p>
<p>The Response team's task can be modeled using a simple Shortest Path Problem, where the Response Team must find the shortest path between Bendigo and the target site. In this algorithm the shortest path between bendigo and a given town must be found using the Edge attribute containing the time to treverse the road. This means the task is optimised for time to reach the target. The algorithm does not need to take into account the straight line distance or the earth's curvature as the vehicles must travel on roads. As this the team only needs to reach the target site the algorithm does not need to take into account factors such as population density, average income, and average age of each town, as the team is not required to stop at any towns along the way. It is assumed that the team only needs to reach the given target, and the vehicle will have an infinite amount of fuel so it can travel any distance without stopping.</p>
<p>// TODO: Add more detail to the second task</p>
<h4>Relevent ADT Signitures</h4>
<ul>
<li>Graph<ul>
<li><strong>get_edge_value</strong>: Graph, Node, Node -&gt; int</li>
<li><strong>get_node_value</strong>: Graph, Node -&gt; dict <span style="color:blue"><em>returns node attributes as a dictionary</em></span></li>
<li><strong>get_nodes</strong>: Graph -&gt; list</li>
<li><strong>get_edges</strong>: Graph -&gt; list</li>
</ul>
</li>
<li>List<ul>
<li><strong>append</strong>: element, List -&gt; List</li>
<li><strong>contains</strong>: element, List -&gt; bool</li>
<li><strong>length</strong>: List -&gt; int</li>
</ul>
</li>
<li>Stack<ul>
<li><strong>push</strong>: element, Stack -&gt; Stack</li>
<li><strong>pop</strong>: Stack -&gt; element</li>
<li><strong>isEmpty</strong>: Stack -&gt; bool</li>
</ul>
</li>
<li>Priority Queue<ul>
<li><strong>enqueue</strong>: element, int -&gt; Priority Queue</li>
<li><strong>dequeue</strong>: Priority Queue -&gt; element</li>
<li><strong>isEmpty</strong>: Priority Queue -&gt; bool</li>
</ul>
</li>
</ul>
<p><img src="./map.png" alt="Graph Model"></p>
<h2>Part 2: <strong>Design your Algorithm</strong></h2>
<p>As previously mentioned, the medical team's task can be modeled as a Travelling Salesman Like Problem (TSP). There are a number of suitable algorithms that all have advantages and disadvantages. The most notable of these being running time and accuracy. As TSP style problems are NP-Hard -- meaning that the time taken to solve the problem cannot be determined in polynomial time -- these are directly related to each other. The more accurate the solution, the longer it will take to solve -- With a few exceptions. These solution types are generally known as Heuristic and Exact solutions, with the former being faster but less accurate and the latter being more accurate but slower.</p>
<p>The simplest solution for a TSP style problem is to generate all possible paths and calculate the time taken to travel each path. This is known as the Brute Force method. This method is the most accurate but is also the slowest. It computes all permutations of the towns and calculates the travel time of each path, before choosing the path with the shortest travel time. This method is quite slow on larger sets as the number of possible paths increases factorially with the number of towns. This method is not suitable for large sets of towns, as the time taken to compute the solution is not feasible, This means that the team would not be able to scale their operation up if the outbreak were to spread outside of Victoria. Although, as this type of algorithm finds all possible solutions, it falls under the exact catagory of solutions, where it is guaranteed to find the optimal solution. It is also more accurate than other solutions, as it does not make any assumptions about the data and will never reach a local minimum. This means that when the number of towns is small, this method is the best to use.</p>
<p>A more optimal TSP solution is the Nearest Neighbour Algorithm. This algorithm is a heuristic solution, meaning that it is not guaranteed to find the optimal solution. This algorithm works by starting at a random town and then visiting the nearest town, then the nearest town to that town, and so on until all towns have been visited. This algorithm is much faster than the Brute Force method, but is less accurate. This algorithm is not guaranteed to find the optimal solution, as it may reach a local minimum. This means that the solution may not be the shortest path, but it will be close to the shortest path. This algorithm is much faster than the Brute Force method, as it only needs to calculate the distance between each town once, and then it can find the shortest path. The main issue with this algotithm for the task listed here is the graph generated as a function of the radius is not always hamiltonian, meaning that the nearest neighbour algorithm may not always find a valid solution or the shortest path. The main cause of this is the core idea of the algorithm, where it chooses only the most locally optimal solution at each step, this means that if node A is the closest to node B, then the algorithm will choose node A, even if the only way to get to node C is through node B. This is the main issue with the nearest neighbour algorithm, as it may completely miss required nodes, or choose a suboptimal path. This is not suitable for the task at hand, as the algorithm must visit all towns within the radius, and the nearest neighbour algorithm may not always do this.</p>
<p>Without the use of Dynamic Programming, Simulated annealing, Backtracking, Genetic Algorithms or Ant Colony Optimization, these are the two most practical algorithms. The Nearest Neighbour solution would potentially require changes in the graph to make it hamiltonian, and it therefor would not generate the most optimal path. A Brute force algorithm would take longer to run and be less scalable than a Nearest Neighbour like design, although it is an Exact algorithm rather than a Heuristic one. The most suitable algorithm for this task is a Brute Force algorithm, as the number of towns is most likley to be less than ten, and the accuracy of the solution is more important than the time taken to compute the solution. If the number of towns were to increase, then a more scalable solution would be required, at the cost of accuracy. This is the most suitable algorithm for the task at hand, as the number of towns is small and the accuracy of the solution is more important than the time taken to compute the solution.</p>
<p>The Research team's task can be modeled as a Shortest Path Problem, where the goal is to find the shortest path between Bendigo and the target site. This is a well-known P problem in graph theory, and there are several algorithms that can be used to solve it. For this task we will focus on exact solution over heuristic solutions as the given restrictions limit the types of solutions that can be used.</p>
<p>Once again the simplest solution for a Shortest Path Problem is to generate all possible paths and calculate the time taken to travel each path. This type of algorithm has almost no advantages over other solutions, as it is not the only exact solution, and it is the slowest. Alike the TSP Brute Force method, The number of towns increase factorially with the number of towns, making it useless for sets of towns with a number of towns greater than four. It still requires the large amount of memory and cpu cycles, therefor should never be used.</p>
<p>One of the two most common algorithms for this task is Dijkstra's Algorithm. Dijkstra's Algorithm is a greedy algorithm that finds the shortest path between two nodes in a graph. It works by starting at the source node and then visiting the nearest node, then the nearest node to that node, and so on until the target node is reached. This algorithm is guaranteed to find the shortest path between two nodes, as it calculates the shortest path to each node from the source node. This algorithm is much faster than the Brute Force method, as it only needs to calculate the distance between each node once, and then it can find the shortest path. This algorithm is quite suitable for the task at hand, as the goal is to find the shortest path between two nodes, and the accuracy of the solution is more important than the time taken to compute the solution. This algorithm would not work though if the graph contained negative edge weights, as the algorithm would not be able to find the shortest path. This is not an issue in this task, as the edge weights are all positive.</p>
<p>The other of these two algorithms is the Bellman-Ford Algorithm. The Bellman-Ford Algorithm is another exact solution to the Shortest Path Problem. This algorithm on the principal of edge relaxation, where the algorithm relaxes the edges of the graph until the shortest path is found. This algorithm is slower than Dijkstra's Algorithm, as it relaxes all edges in the graph for each node, rather than just the nearest node -- meaning it is not a greedy algorithm. This algorithm is more suitable for graphs with negative edge weights, as it can find the shortest path even if the graph contains negative edge weights. Another case where this algorithm is more suitable is when the graph is dense, as the algorithm does not need to maintain priority queues for each node.</p>
<p>The most suitable algorithm for this task is Dijkstra's Algorithm, as the graph is not dense and does not contain negative edge weights. This algorithm is faster than the Bellman-Ford Algorithm, and it is more suitable for the task at hand. In the implementation a prioriy queue will be used to optimise the algorithm slightly. This will mean that paths with shorter distances will be searched first. This algorithm is guaranteed to always find the shortest path between two nodes, this means there is no advantages to brute forcing the solution. In this task there would be almost no reason to choose Bellman Ford or Brute Force over Dijkstra's Algorithm.</p>
<h2>Part 4: Psuedocode</h2>
<h3>4.1.1 Find Towns within Radius</h3>
<pre><code>function BFS(Graph, Start, Radius) -&gt; Node List:
    Queue = New queue containing Start   
    Visited = New List containing Start
    
    while Queue is not empty:
        Current = Dequeue(Queue)
        
        for Neighbour v in Current.neighbours:
            distance = Haversine(Current, v)
            if distance &lt;= Radius and v not in Visited:
                Add v to Queue
                Add v to Visited

    return Visited
</code></pre>
<h3>4.1.2 Medical Team Path</h3>
<pre><code>function tsp(Graph, Start, Radius) -&gt; Node List:
    Towns = BFS(Graph, Start, Radius)
    n = length(Towns)
    dist = New 2D array of size n x n

    for i from 0 to n-1: // Direct Distance between Towns
        for j from 0 to n-1:
            dist[i][j] = The time taken to travel between Towns[i] and Towns[j]

    // Floyd Warshall Algorithm
    for k from 0 to n-1:
        for i from 0 to n-1:
            for j from 0 to n-1:
                dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j])

    min_path = null
    min_dist = infinity

    for path in all permutations of Towns:
        path = list(path)
        path_dist = 0

        for i from 0 to n-2:
            path_dist += dist[path[i]][path[i+1]]

        if path_dist &lt; min_dist:
            min_dist = path_dist
            min_path = path
    return min_path, min_dist
</code></pre>
<h3>4.2.1 Shortest Path to Target</h3>
<pre><code>function dijkstra(Graph, Start, Target) -&gt; Node List:
    Queue = New Priority Queue containing Start with a priority of 0 and All other nodes with a priority of infinity
    Visited = New List containing Start
    Time = New List containing 0 for Start and infinity for all other nodes
    Previous = New List containing null for all nodes

    while Queue is not empty:
        Current = Dequeue(Queue)
        
        for Neighbour v in Current.neighbours:
            time = current.time + Time to travel between Current and v
            if time &lt; Time[v]:
                Time[v] = time
                Previous[v] = Current
                Queue.enqueue(v, time)

    Path = New List
    Current = Target

    while Current is not null:
        Add Current to the front of Path
        Current = Previous[Current]

    return Path
</code></pre>
<h2>Part 4: <strong>Evaluation</strong></h2>
<p>note to self:</p>
<ul>
<li>Team must return to bendigo</li>
</ul>
